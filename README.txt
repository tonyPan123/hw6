First, we can see that different threads uses the same instance of the varlist data structure, which stores information about current variables of the calculator. This is necessary because we want to achieve the communication between clients by using a single Calc instance across different client connections. Since the client is allowed to add or modify the variables, it might be the case that multiple client threads tries to modify the varlist data structure within the Calc struct simultaneously. Thus synchronization is needed here.

We use a mutex lock to achieve synchronization here. The implementation of the calculator, i.e. the class CalcImpl, has a mutex (pthread_mutex_t lock;) as one of the member variables. When initializing the CalcImpl class, pthread_mutex_init is called to initialize the mutex lock. Similarly, pthread_mutex_destroy is called in the destructor of CalcImpl to destroy the lock.

Note that if a thread is only looking at a variable, but not modifying the shared varlist data structure, we just copy over the value that is stored in the space for that variable. Although it may happen that just after the value is copied, the value at that position is changed immediately before the client was able to see the copied value. There is no source of unsynchronization that will lead to strange behavior of the program. However, when it comes to assignment of variable, we can see the source for unsynchronization. Suppose at first a is equal to 0 and both client 1 and client 2 type a = a + 1. Clearly, after such two operations, a should be 2. We know that when we do such assignment, we first copy value of a to register, then + 1, finally copy back. However, without synchronization, we may find that the “copy a’s value” part for both operations will happen sequentially. Then at the register, both operations will got value 1. So when they copy back, the final value for a will be 1 instead of 2 as our expected. So the only critical section is when a thread tries to make an assignment to some variable in the varlist data structure. Specifically, in our code, when we dealing with the situation that we need to assign a variable: we first utilize evaluate(new_tokens, &temp_result) to calculate the value that is needed to be assigned, then we assign it to the space for that variable in the operation varlist[tokens[0]] = temp_result. As we have demonstrated above, for one assigning operation, the fetching, calculating, and copying back must be happen in the same time. Or there will be unsynchronization and strange behavior will happen(like missing adding 1 like we illustrated above). Because evaluate(new_tokens, &temp_result) contain both fetching and calculation, and varlist[tokens[0]] = temp_result is final copying over. So we need to assure that they will happen sequentially and no other operations can intervene them. So what we do is to add pthread_mutex_lock(&lock) before evaluate(new_tokens, &temp_result) and add pthread_mutex_unlock(&lock) after varlist[tokens[0]] = temp_result to make sure the synchronization. So we can see that the critical section is the part that calculate the value for assignment and assign the value. Note that we only add synchronization at such critical section because other sections do not need that and synchronization really slow the operation rate.

By doing this, if two threads are trying to change varlist simultaneous, the thread that locks the mutex slightly earlier will first modify varlist, and the other thread will have to wait until the mutex lock for the first thread is unlocked to proceed further, thus avoiding simultaneous modification of shared data.